由于当前vben admin项目属于第三方平台的链接跳转过来的，没有登陆功能，token是从链接中获取的。我需要怎么改代码，以及要注意的地方
针对第三方平台跳转的场景，我来详细说明需要修改的地方：

## 1. 从 URL 获取 Token

首先创建一个工具函数来获取 URL 参数：

```typescript
// src/utils/url.ts
export function getQueryParam(name: string): string | null {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get(name);
}

export function getHashQueryParam(name: string): string | null {
  const hash = window.location.hash;
  const queryIndex = hash.indexOf('?');
  if (queryIndex === -1) return null;
  
  const queryString = hash.substring(queryIndex + 1);
  const urlParams = new URLSearchParams(queryString);
  return urlParams.get(name);
}
```

## 2. 修改 App.vue 或创建初始化逻辑

在 `src/App.vue` 中添加初始化逻辑：

```typescript
<script lang="ts" setup>
import { onMounted } from 'vue';
import { useUserStore } from '@/store/modules/user';
import { usePermissionStore } from '@/store/modules/permission';
import { getQueryParam, getHashQueryParam } from '@/utils/url';
import { router } from '@/router';
import { PageEnum } from '@/enums/pageEnum';

const userStore = useUserStore();
const permissionStore = usePermissionStore();

onMounted(async () => {
  // 从 URL 获取 token（根据实际情况选择）
  const token = getQueryParam('token') || getHashQueryParam('token');
  
  // 获取其他可能的参数
  const userId = getQueryParam('userId') || getHashQueryParam('userId');
  const userName = getQueryParam('userName') || getHashQueryParam('userName');
  
  if (token && !userStore.getToken) {
    // 设置 token
    userStore.setToken(token);
    
    // 设置用户信息（可以从 URL 参数构建，或者调用接口获取）
    const userInfo = {
      userId: userId || '1',
      username: userName || 'user',
      realName: decodeURIComponent(getQueryParam('realName') || userName || '用户'),
      avatar: '',
      desc: '第三方平台用户',
      homePath: getQueryParam('homePath') || PageEnum.BASE_HOME,
      roles: [
        {
          roleName: 'Admin',
          value: 'admin',
        },
      ],
    };
    
    userStore.setUserInfo(userInfo);
    userStore.setRoleList(['admin']);
    
    // 构建动态路由
    if (!permissionStore.getIsDynamicAddedRoute) {
      const routes = await permissionStore.buildRoutesAction();
      routes.forEach((route) => {
        router.addRoute(route as any);
      });
      permissionStore.setDynamicAddedRoute(true);
    }
    
    // 清理 URL 中的 token 参数（安全考虑）
    const url = new URL(window.location.href);
    url.searchParams.delete('token');
    url.searchParams.delete('userId');
    url.searchParams.delete('userName');
    window.history.replaceState({}, document.title, url.toString());
  }
});
</script>
```

## 3. 修改路由守卫

修改 `src/router/guard/permissionGuard.ts`：

```typescript
export function createPermissionGuard(router: Router) {
  const userStore = useUserStoreWithOut();
  const permissionStore = usePermissionStoreWithOut();
  
  router.beforeEach(async (to, from, next) => {
    // 检查 URL 中的 token
    const urlToken = getQueryParam('token') || getHashQueryParam('token');
    
    if (urlToken && !userStore.getToken) {
      // 设置 token
      userStore.setToken(urlToken);
      
      // 可以在这里获取用户信息或使用默认信息
      try {
        // 如果有获取用户信息的接口
        await userStore.getUserInfoAction();
      } catch (error) {
        // 如果接口失败，使用默认信息
        userStore.setUserInfo({
          userId: '1',
          username: 'user',
          realName: '用户',
          homePath: PageEnum.BASE_HOME,
          roles: [{ roleName: 'Admin', value: 'admin' }],
        });
      }
    }
    
    const token = userStore.getToken;
    
    // 没有 token 且不是白名单路由
    if (!token) {
      // 如果路由配置了 ignoreAuth，直接放行
      if (to.meta.ignoreAuth) {
        next();
        return;
      }
      
      // 第三方平台场景下，可能需要跳转回第三方平台
      if (import.meta.env.VITE_THIRD_PARTY_LOGIN_URL) {
        window.location.href = import.meta.env.VITE_THIRD_PARTY_LOGIN_URL;
        return;
      }
      
      // 否则显示错误页面
      next('/exception/403');
      return;
    }
    
    // 已经添加过动态路由，直接放行
    if (permissionStore.getIsDynamicAddedRoute) {
      next();
      return;
    }
    
    // 构建动态路由
    const routes = await permissionStore.buildRoutesAction();
    routes.forEach((route) => {
      router.addRoute(route as unknown as RouteRecordRaw);
    });
    
    permissionStore.setDynamicAddedRoute(true);
    
    next({ ...to, replace: true });
  });
}
```

## 4. 处理用户信息获取

修改 `src/store/modules/user.ts`：

```typescript
// 修改或添加一个方法来处理第三方登录
async thirdPartyLogin(token: string, userInfo?: any) {
  // 设置 token
  this.setToken(token);
  
  // 如果提供了用户信息，直接使用
  if (userInfo) {
    this.setUserInfo(userInfo);
    return userInfo;
  }
  
  // 否则尝试获取用户信息
  try {
    return await this.getUserInfoAction();
  } catch (error) {
    // 如果获取失败，使用默认信息
    const defaultUserInfo = {
      userId: '1',
      username: 'user',
      realName: '第三方用户',
      avatar: '',
      desc: '',
      homePath: PageEnum.BASE_HOME,
      roles: [
        {
          roleName: 'Admin',
          value: 'admin',
        },
      ],
    };
    this.setUserInfo(defaultUserInfo);
    return defaultUserInfo;
  }
}

// 修改 getUserInfoAction，添加错误处理
async getUserInfoAction(): Promise<UserInfo | null> {
  if (!this.getToken) return null;
  
  try {
    const userInfo = await getUserInfo();
    const { roles = [] } = userInfo;
    
    if (isArray(roles)) {
      const roleList = roles.map((item) => item.value) as RoleEnum[];
      this.setRoleList(roleList);
    } else {
      userInfo.roles = [];
      this.setRoleList([]);
    }
    
    this.setUserInfo(userInfo);
    this.setSessionTimeout(false);
    return userInfo;
  } catch (error) {
    console.error('获取用户信息失败:', error);
    throw error;
  }
}
```

## 5. 隐藏登录相关页面

修改路由配置，移除或隐藏登录路由：

```typescript
// src/router/routes/basic.ts
// 注释掉登录路由或添加 hidden 属性
export const LoginRoute: AppRouteRecordRaw = {
  path: '/login',
  name: 'Login',
  component: () => import('/@/views/sys/login/Login.vue'),
  meta: {
    title: t('routes.basic.login'),
    hidden: true, // 添加 hidden 属性
  },
};
```

## 6. 环境变量配置

在 `.env` 文件中添加配置：

```env
# 第三方平台登录地址
VITE_THIRD_PARTY_LOGIN_URL=https://third-party.com/login

# 是否启用第三方登录模式
VITE_THIRD_PARTY_MODE=true

# Token 参数名称
VITE_TOKEN_PARAM_NAME=token
```

## 7. 退出登录处理

修改退出登录逻辑，跳转回第三方平台：

```typescript
// src/store/modules/user.ts
async logout(goLogin = false) {
  if (this.getToken) {
    try {
      await doLogout();
    } catch {
      console.log('注销Token失败');
    }
  }
  this.setToken(undefined);
  this.setSessionTimeout(false);
  this.setUserInfo(null);
  
  // 第三方平台模式下，跳转回第三方平台
  if (import.meta.env.VITE_THIRD_PARTY_MODE === 'true') {
    const thirdPartyLogoutUrl = import.meta.env.VITE_THIRD_PARTY_LOGOUT_URL;
    if (thirdPartyLogoutUrl) {
      window.location.href = thirdPartyLogoutUrl;
      return;
    }
  }
  
  // 否则跳转到登录页
  if (goLogin) {
    router.push(PageEnum.BASE_LOGIN);
  }
}
```

## 8. 注意事项

### 安全性考虑
1. **Token 验证**：确保 token 的有效性验证
2. **清理 URL**：获取 token 后清理 URL 中的敏感参数
3. **HTTPS**：确保使用 HTTPS 传输 token

### 实现建议
```typescript
// 创建一个专门的第三方登录服务
// src/utils/thirdPartyAuth.ts
export class ThirdPartyAuth {
  static async init() {
    const token = this.getTokenFromUrl();
    if (!token) return false;
    
    const userStore = useUserStore();
    const permissionStore = usePermissionStore();
    
    try {
      // 设置 token
      userStore.setToken(token);
      
      // 获取或设置用户信息
      await this.setupUserInfo();
      
      // 构建路由
      await this.setupRoutes();
      
      // 清理 URL
      this.cleanUrl();
      
      return true;
    } catch (error) {
      console.error('第三方认证初始化失败:', error);
      return false;
    }
  }
  
  static getTokenFromUrl(): string | null {
    return getQueryParam('token') || getHashQueryParam('token');
  }
  
  static async setupUserInfo() {
    const userStore = useUserStore();
    
    // 从 URL 获取用户信息
    const userId = getQueryParam('userId');
    const userName = getQueryParam('userName');
    
    if (userId && userName) {
      userStore.setUserInfo({
        userId,
        username: userName,
        realName: decodeURIComponent(getQueryParam('realName') || userName),
        homePath: PageEnum.BASE_HOME,
        roles: [{ roleName: 'Admin', value: 'admin' }],
      });
    } else {
      // 调用接口获取
      await userStore.getUserInfoAction();
    }
  }
  
  static cleanUrl() {
    const url = new URL(window.location.href);
    url.searchParams.delete('token');
    url.searchParams.delete('userId');
    url.searchParams.delete('userName');
    url.searchParams.delete('realName');
    window.history.replaceState({}, document.title, url.toString());
  }
}
```

### 调试建议
1. 在浏览器控制台查看 token 是否正确获取
2. 检查 Network 面板中的请求头是否包含 token
3. 使用 Vue DevTools 查看 store 中的状态

这样改造后，你的 vben admin 项目就可以支持第三方平台的跳转登录了。