根据你的需求，当用户选择下拉框选项时，需要同时获取 value 数组和 label 数组。这里有几种实现方式：

## 方案一：使用 Ant Design Vue 的 labelInValue 属性

```javascript
// 在模板中
<a-select
  v-model:value="formData.owner"
  mode="multiple"
  :label-in-value="true"
  placeholder="请选择Owner"
  :options="departmentOptions"
  @change="handleOwnerChange"
/>

// 在 script 中
const formData = reactive({
  owner: [], // 这将存储 [{value: 'id', label: 'name'}, ...]
  ownerId: [],
  ownerName: []
})

const handleOwnerChange = (selectedItems) => {
  // selectedItems 格式: [{value: 'id1', label: 'name1'}, {value: 'id2', label: 'name2'}]
  if (selectedItems && selectedItems.length > 0) {
    formData.ownerId = selectedItems.map(item => item.value)
    formData.ownerName = selectedItems.map(item => item.label)
  } else {
    formData.ownerId = []
    formData.ownerName = []
  }
}
```

## 方案二：在 change 事件中查找对应的 label

```javascript
// 保持原有的选择器配置
<a-select
  v-model:value="formData.owner"
  mode="multiple"
  placeholder="请选择Owner"
  :options="departmentOptions"
  @change="handleOwnerChange"
/>

// 在 script 中
const formData = reactive({
  owner: [], // 存储选中的 value 数组
  ownerName: [] // 存储对应的 label 数组
})

const handleOwnerChange = (values) => {
  // values 是选中的 value 数组 ['id1', 'id2']
  formData.owner = values
  
  // 根据 value 查找对应的 label
  formData.ownerName = values.map(value => {
    const option = departmentOptions.value.find(opt => opt.value === value)
    return option ? option.label : ''
  })
}
```

## 方案三：创建一个映射对象便于快速查找

```javascript
// 创建映射对象
const departmentMap = ref({})

const fetchDepartments = async () => {
  loading.value = true
  try {
    const response = await fetch('/api/departments')
    const data = await response.json()
    
    // 转换数据格式并创建映射
    departmentOptions.value = data.map(item => {
      const option = {
        value: item.id,
        label: item.name
      }
      // 创建 value -> label 的映射
      departmentMap.value[item.id] = item.name
      return option
    })
  } catch (error) {
    console.error('获取部门列表失败:', error)
  } finally {
    loading.value = false
  }
}

// 使用映射快速获取 label
const handleOwnerChange = (values) => {
  formData.owner = values
  formData.ownerName = values.map(value => departmentMap.value[value] || '')
}
```

## 方案四：封装一个通用的处理函数

```javascript
// 通用的处理函数
const handleMultiSelectChange = (values, options, field) => {
  if (!values || values.length === 0) {
    formData[`${field}Id`] = []
    formData[`${field}Name`] = []
    return
  }
  
  formData[`${field}Id`] = values
  formData[`${field}Name`] = values.map(value => {
    const option = options.find(opt => opt.value === value)
    return option ? option.label : ''
  })
}

// 使用示例
const handleOwnerChange = (values) => {
  handleMultiSelectChange(values, departmentOptions.value, 'owner')
}

const handleDevOwnerChange = (values) => {
  handleMultiSelectChange(values, departmentOptions.value, 'devOwner')
}

const handleOpOwnerChange = (values) => {
  handleMultiSelectChange(values, departmentOptions.value, 'opOwner')
}
```

## 提交时的完整处理

```javascript
const handleSubmit = () => {
  const submitData = {
    ...formData,
    // owner 相关
    ownerId: formData.owner, // value 数组
    ownerName: formData.ownerName, // label 数组
    
    // devOwner 相关
    devOwnerId: formData.devOwner,
    devOwnerName: formData.devOwnerName,
    
    // opOwner 相关
    opOwnerId: formData.opOwner,
    opOwnerName: formData.opOwnerName
  }
  
  // 如果后端需要特定格式，可以进一步处理
  // 例如：组合成对象数组
  submitData.ownerList = formData.owner.map((id, index) => ({
    id: id,
    name: formData.ownerName[index]
  }))
  
  // 提交表单
  submitForm(submitData)
}
```

推荐使用**方案一（labelInValue）**或**方案三（映射对象）**，因为它们性能较好且代码清晰。如果你的下拉选项数据量不大，方案二也是可行的。
