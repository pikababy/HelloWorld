
### 首次分配权限时默认显示所有菜单且不勾选的实现

在你的权限管理组件中，树状图已经通过 `treeData` 显示所有菜单（基于 `menuData` 构建）。默认不勾选的问题在于 `initCheckedKeys` 函数会根据 `authorityCodes` 设置 `checkedKeys`，但对于**首次分配权限**（用户无现有权限），应传入空数组 `[]`，让所有节点默认未勾选。

#### 核心思路
- 通过组件 props 或外部参数判断是否为“首次分配”（e.g., `isFirstAssign: true`）。
- 如果是首次，`checkedKeys` 初始为空；否则，从权限数据初始化。
- 保持树展开（基于上一个回复的 `expandedKeys`），确保所有菜单可见。

#### 步骤 1: 添加 props 支持首次分配场景
在 `` 中添加 props：

```ts
// ... 其他导入不变

// 新增：组件 props
interface Props {
  isFirstAssign?: boolean;  // 是否首次分配权限
  userPermissions?: string[];  // 用户现有权限（可选）
}

const props = withDefaults(defineProps(), {
  isFirstAssign: false,
  userPermissions: () => [],
});
```

#### 步骤 2: 修改初始化逻辑
- 在 `onMounted` 中，根据 `props.isFirstAssign` 决定是否调用 `initCheckedKeys`。
- 如果首次，`checkedKeys.value = []`；否则，使用 `props.userPermissions`。

更新 `` 部分：

```ts
// ... 其他代码不变（fieldNames, buildMenuTree, treeData, expandedKeys, onCheck, handleSave, handleCancel）

// 选中的权限标识（初始为空）
const checkedKeys = ref([]);

// 从权限数据初始化选中状态
const initCheckedKeys = (authorityCodes: string[]) => {
  checkedKeys.value = authorityCodes.filter(code => 
    menuData.value.some(item => item.authIdentifier === code)
  );  // 过滤只匹配菜单中的权限，避免无效选中
};

// 组件挂载时获取数据
onMounted(async () => {
  try {
    // 获取菜单数据（所有菜单都会显示）
    // const menuResponse = await getMenuList();
    // menuData.value = menuResponse.data;
    
    // 模拟数据（你的所有菜单）
    menuData.value = [
      {
        id: 1,
        menuName: '待办事项',
        authIdentifier: 'UnfinishedList',
        menuType: '0',
        parentMenu: null,
        menuSequence: '1',
        status: '1',
        children: []  // 会由 buildMenuTree 填充
      },
      {
        id: 2,
        menuName: '待办列表',
        authIdentifier: 'TodoList',
        menuType: '0',
        parentMenu: 'UnfinishedList',
        menuSequence: '1',
        status: '1'
      },
      {
        id: 3,
        menuName: '超时列表',
        authIdentifier: 'TimeoutList',
        menuType: '0',
        parentMenu: 'UnfinishedList',
        menuSequence: '2',
        status: '1'
      }
      // ... 添加更多菜单项，确保所有菜单都在数组中
    ];
    
    // 初始化选中状态
    if (props.isFirstAssign) {
      // 首次分配：默认全部不勾选
      checkedKeys.value = [];
      console.log('首次分配：所有菜单未勾选');
    } else {
      // 编辑模式：从用户权限初始化
      initCheckedKeys(props.userPermissions || []);
      console.log('编辑模式：已初始化选中权限', checkedKeys.value);
    }
  } catch (error) {
    console.error('数据加载失败：', error);
  }
});
```

#### 步骤 3: 在父组件中使用
当在父组件渲染这个权限树时，传入 `isFirstAssign`：

```vue


  
    :user-permissions="userAuthCodes"  
  />



// 假设 isNewUser 是从路由/状态判断的（e.g., 新用户为 true）
const isNewUser = true;  // 或 ref/computed
const userAuthCodes = [];  // 新用户为空数组

```

#### 步骤 4: 保持树默认展开（可选，基于上一个回复）
确保 `` 有 `:default-expanded-keys="expandedKeys"`，这样首次加载时所有父菜单展开，子菜单可见（即使未勾选）。

完整 ``（无变化）：
```vue

```

#### 为什么这样有效？
- **显示所有菜单**：`menuData.value` 包含完整菜单列表，`buildMenuTree` 会构建全树（无论选中与否）。
- **默认不勾选**：`checkedKeys = []` 确保无节点预选中，用户需手动勾选。
- **区分场景**：通过 `props.isFirstAssign` 灵活处理首次 vs. 编辑，避免硬编码。
- **性能**：`filter` 在 `initCheckedKeys` 中确保只选中有效权限，防止无效键导致 UI 异常。

#### 调试提示
- 控制台日志：检查 `checkedKeys.value` 是否为空（首次时）。
- 如果菜单不全显示：确认 `menuData` 加载了所有项（e.g., API 返回完整列表），并 log `treeData.value` 验证树结构。
- Ant Design Vue Tree 默认支持“半选”状态（父节点根据子节点联动），首次不勾选时父节点也不会半选。

这样修改后，首次分配时树会展开显示所有菜单，默认无勾选，用户可自由选择保存！如果有实际 API 或更多菜单层级，提供细节我可以细调。