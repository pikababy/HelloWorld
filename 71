我正在使用vben admin开发一个vue3的前端项目，使用了ant design vue作为组件库。当前有一个表格，点击其中一栏可以打开子组件modal框以查看详情，子组件中的详情数据应该什么时候获取？

在 vben admin + Vue3 + Ant Design Vue 的场景下，关于 Modal 子组件中详情数据的获取时机，有几种常见方案，我来分析一下各自的优缺点：

## 方案一：点击时获取数据（推荐）

在父组件中点击表格行时获取数据，然后传递给 Modal 子组件：

```javascript
// 父组件
const handleView = async (record) => {
  loading.value = true;
  try {
    const detailData = await getDetailApi(record.id);
    openModal(true, detailData);
  } finally {
    loading.value = false;
  }
};
```

**优点：**
- 数据实时性好，每次打开都是最新数据
- 不会预加载不必要的数据，节省资源
- 父组件控制数据流，逻辑清晰

**缺点：**
- 每次打开都需要请求，有等待时间

## 方案二：Modal 打开后获取（次推荐）

在 Modal 组件内部监听打开状态，自行获取数据：

```javascript
// Modal 子组件
const [registerModal, { setModalProps }] = useModalInner(async (data) => {
  setModalProps({ loading: true });
  try {
    const detailData = await getDetailApi(data.id);
    // 处理详情数据
  } finally {
    setModalProps({ loading: false });
  }
});
```

**优点：**
- 子组件自管理，职责分离
- 父组件代码简洁
- 符合单一职责原则

**缺点：**
- 子组件需要知道如何获取数据
- 可能造成组件耦合度增加

## 方案三：预加载所有详情（不推荐）

在表格数据加载时就获取所有详情：

```javascript
// 获取表格数据时同时获取详情
const tableData = await getListApi();
const detailsMap = await Promise.all(
  tableData.map(item => getDetailApi(item.id))
);
```

**优点：**
- 打开 Modal 无延迟，体验流畅

**缺点：**
- 初始加载慢，消耗大量资源
- 很多数据可能用不到，造成浪费

## 最佳实践建议

对于 vben admin 项目，我建议采用**方案一**，并结合以下优化：

```typescript
// 父组件
import { useModal } from '/@/components/Modal';
import { getDetailApi } from '/@/api/yourApi';

const [registerModal, { openModal }] = useModal();

// 使用缓存优化
const detailCache = new Map();

const handleView = async (record: any) => {
  // 检查缓存
  if (detailCache.has(record.id)) {
    openModal(true, {
      id: record.id,
      detail: detailCache.get(record.id)
    });
    return;
  }
  
  // 显示加载状态
  const hide = message.loading('加载中...', 0);
  
  try {
    const detail = await getDetailApi(record.id);
    detailCache.set(record.id, detail); // 缓存数据
    
    openModal(true, {
      id: record.id,
      detail
    });
  } catch (error) {
    message.error('获取详情失败');
  } finally {
    hide();
  }
};

// 可选：定时清理缓存
onUnmounted(() => {
  detailCache.clear();
});
```

这样既保证了数据的实时性，又通过缓存优化了用户体验。如果数据更新频繁，可以设置缓存过期时间或在特定操作后清理缓存。




除了子组件的详情数据，比如自组件中的下拉框中的options也是需要使用接口获取，这个获取的时机应该放在哪？

关于子组件中下拉框 options 的获取时机，这确实是个需要仔细考虑的问题。下拉框 options 和详情数据的特性不同，所以处理策略也应该不同。

## 下拉框 Options 的特点

- **相对静态**：通常是字典数据，变化频率低
- **复用性高**：多个组件可能使用相同的 options
- **数据量小**：一般不会很大

## 推荐方案（按优先级）

### 方案一：使用全局状态管理（最推荐）

在 vben admin 中使用 Pinia store 统一管理字典数据：

```typescript
// store/modules/dict.ts
import { defineStore } from 'pinia';
import { getDictApi } from '/@/api/sys/dict';

export const useDictStore = defineStore('dict', {
  state: () => ({
    dictMap: new Map(),
    loading: new Set(), // 正在加载的字典
  }),
  
  actions: {
    async getDict(dictType: string) {
      // 已有缓存直接返回
      if (this.dictMap.has(dictType)) {
        return this.dictMap.get(dictType);
      }
      
      // 正在加载中，等待
      if (this.loading.has(dictType)) {
        await new Promise(resolve => {
          const timer = setInterval(() => {
            if (!this.loading.has(dictType)) {
              clearInterval(timer);
              resolve(true);
            }
          }, 100);
        });
        return this.dictMap.get(dictType);
      }
      
      // 加载数据
      this.loading.add(dictType);
      try {
        const data = await getDictApi(dictType);
        this.dictMap.set(dictType, data);
        return data;
      } finally {
        this.loading.delete(dictType);
      }
    },
    
    // 清除特定字典缓存
    clearDict(dictType?: string) {
      if (dictType) {
        this.dictMap.delete(dictType);
      } else {
        this.dictMap.clear();
      }
    }
  }
});
```

在 Modal 子组件中使用：

```vue
<template>
  <BasicModal @register="registerModal">
    <a-select v-model:value="formData.type" :options="typeOptions" />
  </BasicModal>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { useDictStore } from '/@/store/modules/dict';

const dictStore = useDictStore();
const typeOptions = ref([]);

// Modal 组件初始化时获取
onMounted(async () => {
  typeOptions.value = await dictStore.getDict('business_type');
});
</script>
```

### 方案二：父组件统一获取传递

如果 options 与业务紧密相关，可在父组件统一获取：

```typescript
// 父组件
const handleView = async (record: any) => {
  // 并行获取详情和相关字典
  const [detail, statusOptions, typeOptions] = await Promise.all([
    getDetailApi(record.id),
    getStatusOptionsApi(),
    getTypeOptionsApi()
  ]);
  
  openModal(true, {
    detail,
    options: {
      status: statusOptions,
      type: typeOptions
    }
  });
};
```

### 方案三：组件懒加载 + 缓存

在子组件中首次使用时加载：

```vue
<script setup lang="ts">
import { ref, computed } from 'vue';

// 组件级缓存
const optionsCache = {
  status: null,
  type: null
};

const statusOptions = ref([]);
const typeOptions = ref([]);

// 下拉框获得焦点时加载
const handleStatusFocus = async () => {
  if (!optionsCache.status) {
    const data = await getStatusOptionsApi();
    optionsCache.status = data;
    statusOptions.value = data;
  }
};

// 或使用 computed 自动加载
const lazyTypeOptions = computed(async () => {
  if (!optionsCache.type) {
    optionsCache.type = await getTypeOptionsApi();
  }
  return optionsCache.type;
});
</script>
```

### 方案四：应用初始化时预加载（适合全局通用字典）

```typescript
// main.ts 或 App.vue
import { useDictStore } from '/@/store/modules/dict';

const initApp = async () => {
  const dictStore = useDictStore();
  
  // 预加载常用字典
  await Promise.all([
    dictStore.getDict('common_status'),
    dictStore.getDict('yes_no'),
    dictStore.getDict('gender')
  ]);
};
```

## 综合建议

根据不同场景选择不同方案：

```typescript
// hooks/useModalData.ts
import { useDictStore } from '/@/store/modules/dict';

export function useModalData() {
  const dictStore = useDictStore();
  
  // 获取 Modal 所需的所有数据
  const getModalData = async (id: string, dictTypes: string[] = []) => {
    // 并行获取详情和字典
    const tasks = [getDetailApi(id)];
    
    if (dictTypes.length > 0) {
      tasks.push(...dictTypes.map(type => dictStore.getDict(type)));
    }
    
    const [detail, ...dicts] = await Promise.all(tasks);
    
    // 组装字典数据
    const options = {};
    dictTypes.forEach((type, index) => {
      options[type] = dicts[index];
    });
    
    return { detail, options };
  };
  
  return { getModalData };
}

// 使用
const { getModalData } = useModalData();

const handleView = async (record: any) => {
  const modalData = await getModalData(record.id, ['status', 'type', 'category']);
  openModal(true, modalData);
};
```

## 最佳实践总结

1. **全局通用字典**：使用 Pinia store + 应用启动预加载
2. **业务相关字典**：使用 Pinia store + 按需加载
3. **组件专用选项**：父组件获取或子组件懒加载
4. **考虑缓存策略**：根据数据更新频率设置合理的缓存时间

这样既保证了性能，又维护了代码的整洁性和可维护性。


对于子组件表单的提交事件触发的交易是放在父组件还是子组件？


关于子组件表单提交事件的处理位置，这是个经典的组件设计问题。我来分析几种方案的优缺点：

## 方案对比

### 方案一：子组件处理提交（推荐）

子组件内部完成整个提交流程：

```vue
<!-- 子组件 EditModal.vue -->
<template>
  <BasicModal
    @register="registerModal"
    title="编辑"
    @ok="handleSubmit"
  >
    <BasicForm @register="registerForm" />
  </BasicModal>
</template>

<script setup lang="ts">
import { BasicModal, useModalInner } from '/@/components/Modal';
import { BasicForm, useForm } from '/@/components/Form';
import { createApi, updateApi } from '/@/api/business';

const emit = defineEmits(['success', 'register']);

const [registerForm, { validate, resetFields }] = useForm({
  schemas: formSchemas,
});

const [registerModal, { setModalProps, closeModal }] = useModalInner(async (data) => {
  resetFields();
  setModalProps({ confirmLoading: false });
  
  // 回填表单数据
  if (data?.record) {
    setFieldsValue(data.record);
  }
});

// 提交处理
const handleSubmit = async () => {
  try {
    const values = await validate();
    setModalProps({ confirmLoading: true });
    
    // 根据是否有 id 判断新增或编辑
    if (values.id) {
      await updateApi(values);
      message.success('更新成功');
    } else {
      await createApi(values);
      message.success('创建成功');
    }
    
    closeModal();
    emit('success'); // 通知父组件刷新列表
  } finally {
    setModalProps({ confirmLoading: false });
  }
};
</script>
```

父组件使用：

```vue
<!-- 父组件 -->
<template>
  <div>
    <BasicTable @register="registerTable" />
    <EditModal @register="registerModal" @success="handleSuccess" />
  </div>
</template>

<script setup lang="ts">
const [registerModal, { openModal }] = useModal();
const [registerTable, { reload }] = useTable({...});

// 打开弹窗
const handleEdit = (record) => {
  openModal(true, { record });
};

// 成功后刷新列表
const handleSuccess = () => {
  reload();
};
</script>
```

**优点：**
- ✅ 子组件自包含，职责明确
- ✅ 复用性强，可在多处使用
- ✅ 父组件代码简洁
- ✅ 符合 vben admin 的设计理念

**缺点：**
- 子组件依赖具体 API
- 较难实现复杂的业务流程控制

### 方案二：父组件处理提交

提交事件传递到父组件处理：

```vue
<!-- 子组件 -->
<template>
  <BasicModal
    @register="registerModal"
    @ok="handleSubmit"
  >
    <BasicForm @register="registerForm" />
  </BasicModal>
</template>

<script setup lang="ts">
const emit = defineEmits(['submit', 'register']);

const handleSubmit = async () => {
  const values = await validate();
  emit('submit', values);
};
</script>
```

```vue
<!-- 父组件 -->
<script setup lang="ts">
const handleSubmit = async (values) => {
  try {
    if (values.id) {
      await updateApi(values);
    } else {
      await createApi(values);
    }
    message.success('操作成功');
    closeModal();
    reload();
  } catch (error) {
    // 错误处理
  }
};
</script>
```

**优点：**
- 父组件控制业务流程
- 子组件更纯粹，不依赖具体 API
- 便于实现复杂业务逻辑

**缺点：**
- ❌ 父组件代码臃肿
- ❌ 每个使用处都要写提交逻辑
- ❌ 违背了封装原则

### 方案三：混合模式（最佳实践）

提供默认处理，同时支持自定义：

```vue
<!-- 子组件 EditModal.vue -->
<script setup lang="ts">
interface Props {
  // 自定义提交处理
  customSubmit?: (values: any) => Promise<void>;
  // API 配置
  api?: {
    create?: Function;
    update?: Function;
  };
}

const props = withDefaults(defineProps<Props>(), {
  api: () => ({
    create: createApi,
    update: updateApi
  })
});

const emit = defineEmits(['success', 'register']);

const handleSubmit = async () => {
  try {
    const values = await validate();
    setModalProps({ confirmLoading: true });
    
    // 优先使用自定义提交
    if (props.customSubmit) {
      await props.customSubmit(values);
    } else {
      // 使用默认 API
      if (values.id) {
        await props.api.update?.(values);
      } else {
        await props.api.create?.(values);
      }
    }
    
    message.success('操作成功');
    closeModal();
    emit('success', values);
  } finally {
    setModalProps({ confirmLoading: false });
  }
};
</script>
```

使用示例：

```vue
<!-- 简单场景：使用默认处理 -->
<EditModal @register="registerModal" @success="reload" />

<!-- 复杂场景：自定义处理 -->
<EditModal 
  @register="registerModal" 
  :custom-submit="handleCustomSubmit"
  @success="reload" 
/>

<script setup>
const handleCustomSubmit = async (values) => {
  // 自定义业务逻辑
  await complexBusinessLogic(values);
};
</script>
```

## 进阶封装：使用 Hooks

创建可复用的表单提交逻辑：

```typescript
// hooks/useFormSubmit.ts
export function useFormSubmit(options: {
  api: { create: Function; update: Function };
  beforeSubmit?: (values: any) => any;
  afterSubmit?: (result: any) => void;
}) {
  const loading = ref(false);
  
  const handleSubmit = async (values: any) => {
    loading.value = true;
    try {
      // 提交前处理
      const params = options.beforeSubmit?.(values) ?? values;
      
      // 执行提交
      const result = params.id 
        ? await options.api.update(params)
        : await options.api.create(params);
      
      // 提交后处理
      options.afterSubmit?.(result);
      
      return result;
    } finally {
      loading.value = false;
    }
  };
  
  return {
    loading: readonly(loading),
    handleSubmit
  };
}
```

在子组件中使用：

```vue
<script setup lang="ts">
import { useFormSubmit } from '/@/hooks/useFormSubmit';

const { loading, handleSubmit } = useFormSubmit({
  api: { create: createApi, update: updateApi },
  beforeSubmit: (values) => {
    // 数据预处理
    return transformData(values);
  },
  afterSubmit: () => {
    closeModal();
    emit('success');
  }
});
</script>
```

## 最佳实践建议

根据 vben admin 的架构理念，我推荐：

### 1. 默认规则
- **简单 CRUD**：子组件处理（方案一）
- **复杂业务**：混合模式（方案三）
- **特殊流程**：父组件处理（方案二）

### 2. 判断标准

```typescript
// 适合子组件处理
if (满足以下条件) {
  - 标准 CRUD 操作
  - 提交后仅需刷新列表
  - 无复杂业务关联
  - 组件需要多处复用
}

// 适合父组件处理
if (满足以下条件) {
  - 提交后有复杂流程
  - 需要操作多个 API
  - 涉及多个组件联动
  - 业务逻辑特殊
}
```

### 3. 实际示例

```vue
<!-- 可复用的业务组件 -->
<template>
  <BasicModal v-bind="$attrs" @register="registerModal" @ok="handleSubmit">
    <BasicForm @register="registerForm" />
  </BasicModal>
</template>

<script setup lang="ts">
import { useMessage } from '/@/hooks/web/useMessage';
import { useFormModal } from '/@/hooks/business/useFormModal';

// 封装通用逻辑
const { 
  registerModal, 
  registerForm, 
  handleSubmit 
} = useFormModal({
  schemas: formSchemas,
  api: {
    create: createUserApi,
    update: updateUserApi,
    detail: getUserDetailApi
  },
  // 成功提示
  successMessage: {
    create: '创建成功',
    update: '更新成功'
  },
  // 数据转换
  transformData: (values) => ({
    ...values,
    roleIds: values.roles?.map(r => r.id)
  })
});
</script>
```

总的来说，**优先让子组件自治**，这样能获得更好的封装性和复用性，只在确实需要父组件介入时才上提到父组件处理。


详细说下Vue3中Hooks，它的使用场景，以及最佳实践

## Vue3 Hooks（组合式函数）详解

Vue3 的 Hooks 本质上是利用 Composition API 封装的可复用逻辑函数，类似于 React Hooks 的概念，但更贴合 Vue 的响应式系统。

## 核心概念

### 什么是 Vue3 Hooks？

```typescript
// 一个标准的 Vue3 Hook
export function useCounter(initialValue = 0) {
  const count = ref(initialValue);
  
  const increment = () => count.value++;
  const decrement = () => count.value--;
  const reset = () => count.value = initialValue;
  
  // 返回响应式状态和方法
  return {
    count: readonly(count), // 只读，防止外部直接修改
    increment,
    decrement,
    reset
  };
}
```

### 命名约定
- 以 `use` 开头，如 `useTable`、`useForm`、`useModal`
- 使用驼峰命名法
- 名称应该描述功能而非实现细节

## 使用场景

### 1. 状态逻辑复用

```typescript
// hooks/useUserInfo.ts
export function useUserInfo() {
  const userStore = useUserStore();
  const router = useRouter();
  
  const userInfo = computed(() => userStore.getUserInfo);
  const isAdmin = computed(() => userInfo.value?.role === 'admin');
  
  const logout = async () => {
    await userStore.logout();
    router.push('/login');
  };
  
  return {
    userInfo,
    isAdmin,
    logout
  };
}

// 在多个组件中使用
const { userInfo, isAdmin, logout } = useUserInfo();
```

### 2. 业务逻辑封装

```typescript
// hooks/useTableCrud.ts
export function useTableCrud<T = any>(api: CrudApi) {
  const loading = ref(false);
  const dataSource = ref<T[]>([]);
  const selectedRowKeys = ref<Key[]>([]);
  
  // 查询
  const fetchData = async (params?: any) => {
    loading.value = true;
    try {
      const { items, total } = await api.list(params);
      dataSource.value = items;
      return { items, total };
    } finally {
      loading.value = false;
    }
  };
  
  // 删除
  const handleDelete = async (id: string) => {
    await api.delete(id);
    message.success('删除成功');
    await fetchData();
  };
  
  // 批量删除
  const handleBatchDelete = async () => {
    if (selectedRowKeys.value.length === 0) {
      message.warning('请先选择要删除的数据');
      return;
    }
    
    Modal.confirm({
      title: '确认删除',
      content: `确定删除选中的 ${selectedRowKeys.value.length} 条数据吗？`,
      onOk: async () => {
        await api.batchDelete(selectedRowKeys.value);
        selectedRowKeys.value = [];
        await fetchData();
      }
    });
  };
  
  return {
    loading: readonly(loading),
    dataSource: readonly(dataSource),
    selectedRowKeys,
    fetchData,
    handleDelete,
    handleBatchDelete
  };
}
```

### 3. 副作用管理

```typescript
// hooks/useWebSocket.ts
export function useWebSocket(url: string, options?: WebSocketOptions) {
  const ws = ref<WebSocket | null>(null);
  const data = ref<any>(null);
  const error = ref<Error | null>(null);
  const status = ref<'connecting' | 'connected' | 'disconnected'>('disconnected');
  
  const connect = () => {
    try {
      ws.value = new WebSocket(url);
      status.value = 'connecting';
      
      ws.value.onopen = () => {
        status.value = 'connected';
        options?.onOpen?.();
      };
      
      ws.value.onmessage = (event) => {
        data.value = JSON.parse(event.data);
        options?.onMessage?.(data.value);
      };
      
      ws.value.onerror = (err) => {
        error.value = err as Error;
        options?.onError?.(err);
      };
      
      ws.value.onclose = () => {
        status.value = 'disconnected';
        options?.onClose?.();
      };
    } catch (err) {
      error.value = err as Error;
    }
  };
  
  const disconnect = () => {
    ws.value?.close();
  };
  
  const send = (message: any) => {
    if (ws.value?.readyState === WebSocket.OPEN) {
      ws.value.send(JSON.stringify(message));
    }
  };
  
  // 组件卸载时自动断开
  onUnmounted(() => {
    disconnect();
  });
  
  // 自动连接
  if (options?.autoConnect !== false) {
    onMounted(() => {
      connect();
    });
  }
  
  return {
    data: readonly(data),
    error: readonly(error),
    status: readonly(status),
    connect,
    disconnect,
    send
  };
}
```

### 4. 表单处理

```typescript
// hooks/useFormValidation.ts
export function useFormValidation<T extends Record<string, any>>(
  initialValues: T,
  rules: FormRules
) {
  const formData = reactive<T>({ ...initialValues });
  const errors = reactive<Record<string, string>>({});
  const touched = reactive<Record<string, boolean>>({});
  
  // 验证单个字段
  const validateField = async (field: keyof T) => {
    const rule = rules[field];
    if (!rule) return true;
    
    try {
      await rule.validate(formData[field]);
      errors[field as string] = '';
      return true;
    } catch (err) {
      errors[field as string] = err.message;
      return false;
    }
  };
  
  // 验证所有字段
  const validate = async () => {
    const results = await Promise.all(
      Object.keys(rules).map(field => validateField(field))
    );
    return results.every(result => result);
  };
  
  // 重置表单
  const reset = () => {
    Object.assign(formData, initialValues);
    Object.keys(errors).forEach(key => errors[key] = '');
    Object.keys(touched).forEach(key => touched[key] = false);
  };
  
  // 字段变化处理
  const handleFieldChange = (field: keyof T, value: any) => {
    formData[field] = value;
    touched[field as string] = true;
    
    // 延迟验证
    debounce(() => validateField(field), 300)();
  };
  
  return {
    formData,
    errors: readonly(errors),
    touched: readonly(touched),
    validateField,
    validate,
    reset,
    handleFieldChange
  };
}
```

## 最佳实践

### 1. 目录结构组织

```
src/
├── hooks/
│   ├── web/                 # 通用 Web 相关
│   │   ├── useTitle.ts
│   │   ├── usePageLoading.ts
│   │   └── useEventListener.ts
│   ├── business/            # 业务相关
│   │   ├── useUserManage.ts
│   │   ├── useOrderProcess.ts
│   │   └── useProductList.ts
│   ├── component/           # 组件相关
│   │   ├── useTable.ts
│   │   ├── useForm.ts
│   │   └── useModal.ts
│   └── core/               # 核心功能
│       ├── useRequest.ts
│       ├── useAuth.ts
│       └── usePermission.ts
```

### 2. 参数设计原则

```typescript
// ❌ 不好的设计：参数过多
function useBadExample(
  url: string,
  method: string,
  headers: object,
  timeout: number,
  retry: number,
  cache: boolean
) { }

// ✅ 好的设计：使用配置对象
interface UseRequestOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  headers?: Record<string, string>;
  timeout?: number;
  retry?: number;
  cache?: boolean;
}

function useRequest(url: string, options: UseRequestOptions = {}) {
  const { 
    method = 'GET',
    timeout = 5000,
    retry = 3,
    cache = false 
  } = options;
  // ...
}
```

### 3. 返回值设计

```typescript
// ✅ 返回值清晰、一致
export function useAsyncData<T = any>(fetcher: () => Promise<T>) {
  const data = ref<T | null>(null);
  const error = ref<Error | null>(null);
  const loading = ref(false);
  
  const execute = async (...args: any[]) => {
    loading.value = true;
    error.value = null;
    
    try {
      data.value = await fetcher(...args);
      return data.value;
    } catch (err) {
      error.value = err as Error;
      throw err;
    } finally {
      loading.value = false;
    }
  };
  
  // 返回统一格式
  return {
    // 状态 - 使用 readonly 防止外部修改
    data: readonly(data),
    error: readonly(error),
    loading: readonly(loading),
    
    // 方法
    execute,
    
    // 计算属性
    isReady: computed(() => !loading.value && !error.value)
  };
}
```

### 4. 生命周期管理

```typescript
export function useIntersectionObserver(
  target: Ref<Element | null>,
  callback: IntersectionObserverCallback,
  options?: IntersectionObserverInit
) {
  let observer: IntersectionObserver | null = null;
  
  const stop = () => {
    if (observer) {
      observer.disconnect();
      observer = null;
    }
  };
  
  const start = () => {
    stop();
    
    if (target.value) {
      observer = new IntersectionObserver(callback, options);
      observer.observe(target.value);
    }
  };
  
  // 监听目标元素变化
  watchEffect(() => {
    start();
  });
  
  // 组件卸载时清理
  onUnmounted(() => {
    stop();
  });
  
  return {
    stop,
    start
  };
}
```

### 5. TypeScript 类型支持

```typescript
// 泛型支持
export function useList<T extends Record<string, any>>(
  fetcher: (params: any) => Promise<{ items: T[]; total: number }>
) {
  const list = ref<T[]>([]);
  const total = ref(0);
  const loading = ref(false);
  
  // 分页参数
  const pagination = reactive({
    current: 1,
    pageSize: 10
  });
  
  // 获取数据
  const fetchList = async (params?: Partial<typeof pagination>) => {
    loading.value = true;
    try {
      const mergedParams = { ...pagination, ...params };
      const { items, total: totalCount } = await fetcher(mergedParams);
      
      list.value = items;
      total.value = totalCount;
      
      if (params) {
        Object.assign(pagination, params);
      }
    } finally {
      loading.value = false;
    }
  };
  
  return {
    list: readonly(list) as Readonly<Ref<T[]>>,
    total: readonly(total),
    loading: readonly(loading),
    pagination: readonly(pagination),
    fetchList,
    refresh: () => fetchList(),
    setPage: (page: number) => fetchList({ current: page })
  };
}
```

### 6. 组合多个 Hooks

```typescript
// hooks/useUserTable.ts
export function useUserTable() {
  // 组合多个 hooks
  const { hasPermission } = usePermission();
  const { openModal, register: registerModal } = useModal();
  const { message } = useMessage();
  
  // 使用通用的表格 hook
  const {
    list,
    loading,
    pagination,
    fetchList,
    refresh
  } = useList(getUserListApi);
  
  // 添加业务逻辑
  const handleEdit = (record: User) => {
    if (!hasPermission('user:edit')) {
      message.error('无编辑权限');
      return;
    }
    openModal(true, { record });
  };
  
  const handleDelete = async (id: string) => {
    if (!hasPermission('user:delete')) {
      message.error('无删除权限');
      return;
    }
    
    await deleteUserApi(id);
    message.success('删除成功');
    refresh();
  };
  
  // 初始化加载
  onMounted(() => {
    fetchList();
  });
  
  return {
    // 表格数据
    dataSource: list,
    loading,
    pagination,
    
    // 操作方法
    handleEdit,
    handleDelete,
    refresh,
    
    // Modal 注册
    registerModal
  };
}
```

### 7. 错误处理

```typescript
export function useErrorHandler() {
  const errors = ref<Error[]>([]);
  
  const handleError = (error: Error, context?: string) => {
    console.error(`Error in ${context || 'unknown context'}:`, error);
    errors.value.push(error);
    
    // 根据错误类型处理
    if (error.name === 'NetworkError') {
      message.error('网络连接失败，请检查网络');
    } else if (error.name === 'ValidationError') {
      message.warning(error.message);
    } else {
      message.error('操作失败：' + error.message);
    }
  };
  
  const clearErrors = () => {
    errors.value = [];
  };
  
  // 包装异步函数，自动处理错误
  const wrapAsync = <T extends (...args: any[]) => Promise<any>>(
    fn: T,
    context?: string
  ): T => {
    return (async (...args: Parameters<T>) => {
      try {
        return await fn(...args);
      } catch (error) {
        handleError(error as Error, context);
        throw error;
      }
    }) as T;
  };
  
  return {
    errors: readonly(errors),
    handleError,
    clearErrors,
    wrapAsync
  };
}
```

## 实战示例：完整的数据管理 Hook

```typescript
// hooks/useDataManager.ts
interface UseDataManagerOptions<T> {
  // API 配置
  api: {
    list: (params: any) => Promise<{ items: T[]; total: number }>;
    create?: (data: T) => Promise<T>;
    update?: (id: string, data: T) => Promise<T>;
    delete?: (id: string) => Promise<void>;
    batchDelete?: (ids: string[]) => Promise<void>;
  };
  
  // 选项
  immediate?: boolean;  // 是否立即加载
  defaultPageSize?: number;
  
  // 回调
  onSuccess?: (action: string) => void;
  onError?: (error: Error) => void;
}

export function useDataManager<T extends { id: string }>(
  options: UseDataManagerOptions<T>
) {
  const { api, immediate = true, defaultPageSize = 10 } = options;
  
  // 状态
  const list = ref<T[]>([]);
  const total = ref(0);
  const loading = ref(false);
  const creating = ref(false);
  const updating = ref(false);
  const deleting = ref(false);
  const selectedRowKeys = ref<string[]>([]);
  
  // 分页
  const pagination = reactive({
    current: 1,
    pageSize: defaultPageSize,
    showSizeChanger: true,
    showQuickJumper: true,
    showTotal: (total: number) => `共 ${total} 条`
  });
  
  // 搜索参数
  const searchParams = ref<Record<string, any>>({});
  
  // 获取列表
  const fetchList = async (params?: any) => {
    loading.value = true;
    try {
      const { items, total: totalCount } = await api.list({
        ...searchParams.value,
        ...params,
        page: pagination.current,
        pageSize: pagination.pageSize
      });
      
      list.value = items;
      total.value = totalCount;
      
      options.onSuccess?.('fetch');
    } catch (error) {
      options.onError?.(error as Error);
      throw error;
    } finally {
      loading.value = false;
    }
  };
  
  // 创建
  const create = async (data: Omit<T, 'id'>) => {
    if (!api.create) {
      throw new Error('Create API not provided');
    }
    
    creating.value = true;
    try {
      const result = await api.create(data as T);
      await fetchList();
      options.onSuccess?.('create');
      return result;
    } catch (error) {
      options.onError?.(error as Error);
      throw error;
    } finally {
      creating.value = false;
    }
  };
  
  // 更新
  const update = async (id: string, data: Partial<T>) => {
    if (!api.update) {
      throw new Error('Update API not provided');
    }
    
    updating.value = true;
    try {
      const result = await api.update(id, data as T);
      await fetchList();
      options.onSuccess?.('update');
      return result;
    } catch (error) {
      options.onError?.(error as Error);
      throw error;
    } finally {
      updating.value = false;
    }
  };
  
  // 删除
  const remove = async (id: string) => {
    if (!api.delete) {
      throw new Error('Delete API not provided');
    }
    
    deleting.value = true;
    try {
      await api.delete(id);
      
      // 如果删除后当前页没有数据，回到上一页
      if (list.value.length === 1 && pagination.current > 1) {
        pagination.current--;
      }
      
      await fetchList();
      options.onSuccess?.('delete');
    } catch (error) {
      options.onError?.(error as Error);
      throw error;
    } finally {
      deleting.value = false;
    }
  };
  
  // 批量删除
  const batchRemove = async (ids?: string[]) => {
    const targetIds = ids || selectedRowKeys.value;
    
    if (targetIds.length === 0) {
      message.warning('请先选择要删除的数据');
      return;
    }
    
    if (!api.batchDelete) {
      // 如果没有批量删除接口，逐个删除
      for (const id of targetIds) {
        await remove(id);
      }
    } else {
      deleting.value = true;
      try {
        await api.batchDelete(targetIds);
        selectedRowKeys.value = [];
        await fetchList();
        options.onSuccess?.('batchDelete');
      } catch (error) {
        options.onError?.(error as Error);
        throw error;
      } finally {
        deleting.value = false;
      }
    }
  };
  
  // 搜索
  const search = (params: Record<string, any>) => {
    searchParams.value = params;
    pagination.current = 1;
    return fetchList();
  };
  
  // 重置
  const reset = () => {
    searchParams.value = {};
    pagination.current = 1;
    return fetchList();
  };
  
  // 分页变化
  const handleTableChange = (pag: any) => {
    pagination.current = pag.current;
    pagination.pageSize = pag.pageSize;
    return fetchList();
  };
  
  // 选择变化
  const handleSelectChange = (keys: string[]) => {
    selectedRowKeys.value = keys;
  };
  
  // 立即加载
  if (immediate) {
    onMounted(() => fetchList());
  }
  
  return {
    // 状态
    list: readonly(list),
    total: readonly(total),
    loading: readonly(loading),
    creating: readonly(creating),
    updating: readonly(updating),
    deleting: readonly(deleting),
    
    // 分页
    pagination,
    
    // 选择
    selectedRowKeys,
    rowSelection: computed(() => ({
      selectedRowKeys: selectedRowKeys.value,
      onChange: handleSelectChange
    })),
    
    // 方法
    fetchList,
    create,
    update,
    remove,
    batchRemove,
    search,
    reset,
    refresh: fetchList,
    handleTableChange
  };
}
```

## 总结

Vue3 Hooks 的核心价值在于：
1. **逻辑复用**：相同的业务逻辑可以在多个组件间共享
2. **关注点分离**：将复杂的逻辑从组件中抽离
3. **类型安全**：配合 TypeScript 提供完整的类型支持
4. **测试友好**：纯函数更容易测试
5. **组合灵活**：可以灵活组合多个 Hooks

遵循这些最佳实践，可以让你的 Vue3 项目更加清晰、可维护和可扩展。
